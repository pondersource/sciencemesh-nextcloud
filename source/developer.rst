
Developer Documentation
=======================
The 'sciencemesh' app for Nextcloud adds API endpoints so that Nextcloud
can serve as a user backend, a shares backend, and a storage backend for revad.

API Architecture
----------------

_This chapter of the developer documentation was the deliverable for work package 2b of the sciencemesh-nextcloud project_

Invitation flow API
~~~~~~~~~~~~~~~~~~~
Nextcloud already supports OCM out of the box, but not the invitation-first flow that is used on the ScienceMesh.
There are three systems involved:
* _nextcloud-sender_ (Nextcloud server of the sender)
* _revad-sender_ (IOP server of the sender)
* _receiver_ (the receiver's system; opaque for this part of the flow)

Obtaining the invite token (from Nextcloud GUI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-by-step, this is how it works for the sender if the sending user uses the Nextcloud GUI to generate the invite token:

1. The sending user uses the GUI of _nextcloud-sender_ to request the generation of an invite token.
2. This results in a REST call from _nextcloud-sender_ to _revad-sender_:
* Method: POST
* Content Type: JSON
* URL: https://revad-sender/ocm/invitation/generate
* Request Body: empty
* Authentication: http basic auth, with the sending user's actual username, but with _<loopback-secret>_ as the password (this is because the server-side PHP code does not know the user's real password)
1. Inside revad, this http request triggers a grpc request, including the username and loopback secret
2. The _<loopback-secret>_ is checked by reva's Nextcloud-based auth backend (note that both the loopback secret and the user's actual password will grant access)
3. The invite token is generated by reva
4. The token is returned from the grpc call within _revad-sender_
5. The token is returned from the rest call back to _nextcloud-sender_
6. The token is displayed in the GUI, for the sending user to copy and relay out-of-band to the receiving user.

Obtaining the invite token (from Reva CLI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-by-step, this is how it works for the sender if the sending user uses the Reva CLI to generate the invite token:

1. The sending user uses the CLI client of _revad-sender_ to request the generation of an invite token.
2. The reva CLI tool sends a grpc request, including the _<clientID>_ and _<clientSecret>_
3. This results in a REST call from _sending-revad_ to _sending-nextcloud_:
* Method: POST
* Content Type: JSON
* URL: https://nextcloud-sender/index.php/apps/sciencemesh/api/auth/Authenticate
* Request Body: e.g. '{"clientID":"einstein","clientSecret":"relativity"}'
* X-Reva-Secret header: _<shared-secret>_
1. The _<clientID>_ and _<clientSecret>_  are checked by reva's Nextcloud-based auth backend (note that both the loopback secret and the user's actual password will grant access)
2. A JSON-serialized CS3 User object is returned.
3. The token is generated by _revad-sender_.
4. The token is returned from the grpc call
5. The token is displayed in the CLI tool, for the sending user to copy and relay out-of-band to the receiving user.

Accepting the invite token
~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-by-step, this is how it works for the receiver:
There are again three systems involved:
* _sender_ (the sender's system; opaque for this part of the flow)
* _revad-receiver_ (IOP server of the receiver)
* _nextcloud-receiver_ (Nextcloud server of the receiver)

The receiving user either pastes the token into the Nextcloud GUI, or into reva-cli. Authentication works the same way
as on the sending side:
* If coming through the Nextcloud GUI, the Nextcloud-based user manager verifies username + loopback secret
* If coming through the Reva CLI, the Nextcloud-based user manager verifies username + user password

A REST call for 'forward OCM invite' is made from _revad-receiver_ to _nextcloud-receiver_. Note that the 'forward' here may feel like a bit of a misnomer, but it probably refers
to the fact that all the receiving revad effectively does is take the token from the message body and launch an almost identical request to it. So it really is a case of "forwarding the message":

 _receiving_user_ -("Forward this invite acceptance notice!")-> _receiving_revad_ -("Here is an invite acceptance notice!")-> _sending-revad_

A REST call for 'accept OCM invite' made from _nextcloud-receiver_ to _sender_. Note that this again feels like a misnomer because _sending-revad_ is not ordered to accept the invite, it is just
receiving the information that the receiver has done so.

Creating the share (sender-side, from Nextcloud GUI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When the sending user looks for a recipient to share a resource with, and starts typing the recipient identifier, the autocomplete function gathers search results from a number of share providers,
one of which will be ScienceMesh.
The ScienceMesh share provider compares the characters typed so far to names of users who accepted the sender's invite, and provides an autocomplete result.
If the user clicks this, a rest call to https://revad-sender/ocm/send will be made
For authentication, the username and `loopback-secret` will be sent by Nextcloud, and they will loop back to Nextcloud in a user authentication request.

Creating the share (sender-side, from Reva CLI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The sender can also call `ocm-share-create` in the Reva CLI using their username and password.
This would then similarly result in a call to the OCM Core share provider service, and the OCM share manager driver, which results in:
* a rest call to _nextcloud-sender_ (this time authenticated with username and the user's actual password), to store the sent share on the sender side.

Creating the share (sender-side, common part)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
After that, in both cases, it will trigger a call to the CreateOCMShare method of the OCM share provider service, and the OCM share manager driver, which results in:
* an `addSentShare` rest call to _nextcloud-sender_ (authenticated this time with `X-Reva-Secret`), to store the sent share on the sender side
* an OCM /shares POST to _nextcloud-receiver_ (unauthenticated except for the client IP check)

Creating the share (receiver-side)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When the OCM /shares POST comes in, it triggers a call to the CreateOCMCoreShare method (not "CreateOCMShare method") of the OCM Core service (not "OCM share provider service"),
which also triggers Share function of the OCM share manager driver. So the code paths sound very similar but are subtly different:
* on the sending side it is the *CreateOCMShare* method of the *OCM share provider* service that triggers the Share method of the OCM share manager driver
* on the receiving side it is the *CreateOCMCoreShare* method of the *OCM Core provider* service that triggers the Share method of the OCM share manager driver

The Share method of the OCM share manager driver figures out whether the share was generated locally, and if not, concludes that it must be on the receiving side.
Then, an `addReceivedShare` rest call is made to _nextcloud-sender_ (authenticated with `X-Reva-Secret`), to store the sent share on the sender side.


File sharing API
~~~~~~~~~~~~~~~~

In a future version we will also implement data transfer shares that trigger an rclone job, but for now,
all received shares just result in a webdav mount on the receiver side.

So when the receiver accesses the resource that was shared with them, the data is actually fetched from the source in real-time.

Accessing the received share file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When the receiver access the resource through their Nextcloud GUI, the _receiving_nextcloud_ will see in its database that the given path is a webdav mount.
It will do a webdav request to _sending-revad_.
This will lead to `GetMD` and `InitiateDownload` calls to _sending-nextcloud_.
The file contents are delivered along the following path:
```
sending-nextcloud -> sending-revad -> receiving-nextcloud -> webbrowser
```

Similarly, the receiver can access the resource through their Nextcloud WebDAV interface, from their Nextcloud Mobile app, through their Reva CLI or their revad's WebDAV interface.


Registration flow API
~~~~~~~~~~~~~~~~~~~~~
The registration for ScienceMesh is currently still quite a manual process. See _admin.
