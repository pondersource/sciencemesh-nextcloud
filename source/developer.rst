
Developer Documentation
=======================
The 'sciencemesh' app for Nextcloud adds API endpoints so that Nextcloud
can serve as a user backend, a shares backend, and a storage backend for revad.

API Architecture
----------------

_This chapter of the developer documentation was the deliverable for work package 2b of the sciencemesh-nextcloud project_



Invitation flow API
~~~~~~~~~~~~~~~~~~~
Nextcloud already supports OCM out of the box, but not the invitation-first flow that is used on the ScienceMesh.
There are three systems involved:
* _nextcloud-sender_ (Nextcloud server of the sender)
* _revad-sender_ (IOP server of the sender)
* _receiver_ (the receiver's system; opaque for this part of the flow)

Obtaining the invite token (from Nextcloud GUI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-by-step, this is how it works for the sender if the sending user uses the Nextcloud GUI to generate the invite token:

1. The sending user uses the GUI of _nextcloud-sender_ to request the generation of an invite token.
2. This results in a REST call from _nextcloud-sender_ to _revad-sender_:
* Method: POST
* Content Type: JSON
* URL: https://revad-sender/ocm/invitation/generate
* Request Body: empty
* Authentication: _<shared-secret>_
3. Inside revad, this http request triggers a grpc request, including the _<shared-secret>_
4. The _<shared-secret>_ is checked by reva's Nextcloud-based auth backend
5. The token is generated
6. The token is returned from the grpc call within _revad-sender_
7. The token is returned from the rest call back to _nextcloud-sender_
8. The token is displayed in the GUI, for the sending user to copy and relay out-of-band to the receiving user.

Obtaining the invite token (from Reva CLI)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Step-by-step, this is how it works for the sender if the sending user uses the Reva CLI to generate the invite token:

1. The sending user uses the CLI client of _revad-sender_ to request the generation of an invite token.
2. The reva CLI tool sends a grpc request, including the _<clientID>_ and _<clientSecret>_
3. This results in a REST call from _sending-revad_ to _sending-nextcloud_:
* Method: POST
* Content Type: JSON
* URL: https://nextcloud-sender/index.php/apps/sciencemesh/api/auth/Authenticate
* Request Body: e.g. '{"clientID":"einstein","clientSecret":"relativity"}'
* Authentication: _<shared-secret>_
4. The _<clientID>_ and _<clientSecret>_ are checked against whatever user backend the Nextcloud server uses.
5. A JSON-serialized CS3 User object is returned.
6. The token is generated by _revad-sender_.
6. The token is returned from the grpc call
7. The token is displayed in the CLI tool, for the sending user to copy and relay out-of-band to the receiving user.




Step-by-step, this is how it works for the receiver:
There are again three systems involved:
* _sender_ (the sender's system; opaque for this part of the flow) 
* _revad-receiver_ (IOP server of the receiver)
* _nextcloud-receiver_ (Nextcloud server of the receiver)

File sharing API
~~~~~~~~~~~~~~~~

Registration flow API
~~~~~~~~~~~~~~~~~~~~~
